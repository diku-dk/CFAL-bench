OriginalAcc:
\a0 a1 a2 ->
  let
    T1 a3 =
      let
        T2 a3 a4 = awhile
                     (\(T2 a3 a4) ->
                        map
                          (\(x0, ()) -> x0)
                          (map (\x0 -> let () = () in (x0 < (a2 ! ()), ())) a4))
                     (\(T2 a3 a4) ->
                        T2 (let a5 = a3
                            in
                            zipWith
                              (\(T3 (T3 x0 x1 x2) x3 (T3 x4 x5 x6)) (T3 x7
                                                                        x8
                                                                        x9) ->
                                 T3 (T3 x0 x1 x2) x3 (T3 x4 x5 x6))
                              a5
                              (fold
                                 (\(T3 x0 x1 x2) (T3 x3 x4 x5) ->
                                    let
                                      T3 x6 x7 x8 = T3 x0 x1 x2
                                      T3 x9 x10 x11 = T3 x3 x4 x5
                                    in
                                    (let
                                       T2 x12 x13 = T2 x9 x10
                                       T2 x14 x15 = T2 x6 x7
                                     in
                                     T2 (x14 + x12) (x15 + x13), x8 + x11))
                                 (T3 0.0 0.0 0.0)
                                 (let
                                    a6 = map
                                           (\(T3 (T3 x0 x1 x2)
                                                 x3
                                                 (T3 x4 x5 x6)) ->
                                              let
                                                T2 (T3 x7 x8 x9)
                                                   x10 = T2 (T3 x0 x1 x2) x3
                                              in
                                              T2 (T3 x7 x8 x9) x10)
                                           a5
                                  in
                                  zipWith
                                    (\(T2 (T3 x0 x1 x2) x3) (T2 (T3 x4 x5 x6)
                                                                x7) ->
                                       let
                                         () = ()
                                         T2 (T3 x8 x9 x10) x11 = T2 (T3 x4
                                                                        x5
                                                                        x6)
                                                                    x7
                                         T3 x12 x13 x14 =
                                           let
                                             T3 x12 x13 x14 = T3 x8 x9 x10
                                             T3 x15 x16 x17 = T3 x0 x1 x2
                                           in
                                           (let
                                              T2 x18 x19 = T2 x15 x16
                                              T2 x20 x21 = T2 x12 x13
                                            in
                                            T2 (x20 - x18) (x21 - x19), x14
                                           - x17)
                                         T3 x15 x16 x17 = T3 x12 x13 x14
                                         x18 = x11
                                             *
                                             (let
                                                x18 = 1.0
                                                    /
                                                    sqrt
                                                      ((let
                                                          T3 x18
                                                             x19
                                                             x20 = T3 x12
                                                                      x13
                                                                      x14
                                                          T3 x21
                                                             x22
                                                             x23 = T3 x12
                                                                      x13
                                                                      x14
                                                        in
                                                        (let
                                                           T2 x24 x25 = T2 x21
                                                                           x22
                                                           T2 x26 x27 = T2 x18
                                                                           x19
                                                         in
                                                         x24 * x26 + x25 * x27)
                                                        + x23 * x20)
                                                       + 1.0e-9)
                                              in
                                              x18 * x18 * x18)
                                       in
                                       (let T2 x19 x20 = T2 x15 x16
                                        in
                                        T2 (x18 * x19) (x18 * x20), x18 * x17))
                                    (replicate
                                       (let () = ()
                                        in
                                        T2 (let T1 x0 = (shape a6) in x0) ())
                                       a6)
                                    (replicate
                                       (let () = ()
                                        in
                                        T1 (), let T1 x0 = (shape a6) in x0)
                                       a6))))
                           (map (\x0 -> x0 + 1) a4))
                     (T2 (generate
                            (let () = () in T1 a1 ! ())
                            (\(T1 x0) ->
                               let () = ()
                               in
                               (let x1 = fromIntegral x0
                                in
                                T2 (T3 (sin x1) (cos x1) (tan x1))
                                   (sin (x1 + 1.1)), let x1 = 0.0
                                                     in
                                                     T3 x1 x1 x1)))
                         (unit 0))
      in
      T1 a3
  in
  a3

Desugared OperationAcc:
\T1 (b0: [Double]) ->
  \T1 (b1: [Int]) ->
    \T1 (b2: [Int]) ->
      T1 (e0: Int) =
        compute let () = () in T1 (let x0 = toIndex () () in (b1 !! x0))
      b3: [Double]¹ = alloc Double[Z :. e0]
      b4: [Double]¹ = alloc Double[Z :. e0]
      b5: [Double]¹ = alloc Double[Z :. e0]
      b6: [Double]¹ = alloc Double[Z :. e0]
      b7: [Double]¹ = alloc Double[Z :. e0]
      b8: [Double]¹ = alloc Double[Z :. e0]
      b9: [Double]¹ = alloc Double[Z :. e0]
      execute
        generate
        ( \(T1 x0) ->
            let () = ()
            in
            (let x1 = fromIntegral x0
             in
             T2 (T3 (sin x1) (cos x1) (tan x1)) (sin (x1 + 1.1)), let x1 = 0.0
                                                                  in
                                                                  T3 x1 x1 x1)
        , out (Z :. e0) ((((), T3 b3 b4 b5), b6), T3 b7 b8 b9) )
      e1: Int = compute 0
      b10: [Int] = unit e1
      T2 (T2 (e2: Int)
             (T3 (T3 (b11: [Double]) (b12: [Double]) (b13: [Double]))
                 (b14: [Double])
                 (T3 (b15: [Double]) (b16: [Double]) (b17: [Double]))))
         (T1 (b18: [Int])) =
        awhile ( ( ()
        , ( ((), Int)
        , ( (((), T3 [Double] [Double] [Double]), [Double])
        , T3 [Double] [Double] [Double] ) ) )
        , T1 [Int] )
          ( \T2 (T2 (e2: Int)
                    (T3 (T3 (b11: [Double]) (b12: [Double]) (b13: [Double]))
                        (b14: [Double])
                        (T3 (b15: [Double]) (b16: [Double]) (b17: [Double]))))
                (T1 (b18: [Int])) ->
              T1 (b19: [Word8]) =
                b19: [Word8]¹ = alloc Word8[Z]
                execute
                  map
                  ( \x0 ->
                      let () = ()
                      in
                      (x0 < (let x1 = toIndex () () in (b2 !! x1)), ())
                  , in (Z) b18
                  , out (Z) (b19, ()) )
                return (T1 b19)
              compute (b19 !! 0)
          )
          ( \T2 (T2 (e2: Int)
                    (T3 (T3 (b11: [Double]) (b12: [Double]) (b13: [Double]))
                        (b14: [Double])
                        (T3 (b15: [Double]) (b16: [Double]) (b17: [Double]))))
                (T1 (b18: [Int])) ->
              b19: [Double]¹ = alloc Double[Z :. e2]
              b20: [Double]¹ = alloc Double[Z :. e2]
              b21: [Double]¹ = alloc Double[Z :. e2]
              b22: [Double]¹ = alloc Double[Z :. e2]
              execute
                map
                ( \(T3 (T3 x0 x1 x2) x3 (T3 x4 x5 x6)) ->
                    let T2 (T3 x7 x8 x9) x10 = T2 (T3 x0 x1 x2) x3
                    in
                    T2 (T3 x7 x8 x9) x10
                , in (Z :. e2) ((((), T3 b11 b12 b13), b14), T3 b15 b16 b17)
                , out (Z :. e2) (((), T3 b19 b20 b21), b22) )
              T2 (e3: Int) () =
                compute let () = () in T2 (let T1 x0 = T1 e2 in x0) ()
              T2 (e4: Int) (e5: Int) = compute indexFull (T2 e3 ()) (T1 e2)
              b23: [Double]¹ = alloc Double[Z :. e4 :. e5]
              b24: [Double]¹ = alloc Double[Z :. e4 :. e5]
              b25: [Double]¹ = alloc Double[Z :. e4 :. e5]
              b26: [Double]¹ = alloc Double[Z :. e4 :. e5]
              execute
                backpermute
                ( \(T2 x0 x1) -> indexSlice (T2 e3 ()) (T2 x0 x1)
                , in (Z :. e2) (((), T3 b19 b20 b21), b22)
                , out (Z :. e4 :. e5) (((), T3 b23 b24 b25), b26) )
              T1 () = compute let () = () in T1 ()
              e6: Int = compute let T1 x0 = T1 e2 in x0
              T2 (e7: Int) (e8: Int) = compute indexFull (T2 () e6) (T1 e2)
              b27: [Double]¹ = alloc Double[Z :. e7 :. e8]
              b28: [Double]¹ = alloc Double[Z :. e7 :. e8]
              b29: [Double]¹ = alloc Double[Z :. e7 :. e8]
              b30: [Double]¹ = alloc Double[Z :. e7 :. e8]
              execute
                backpermute
                ( \(T2 x0 x1) -> indexSlice (T2 () e6) (T2 x0 x1)
                , in (Z :. e2) (((), T3 b19 b20 b21), b22)
                , out (Z :. e7 :. e8) (((), T3 b27 b28 b29), b30) )
              e9: Int = compute min e4 e7
              e10: Int = compute min e5 e8
              b31: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b32: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b33: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b34: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b35: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b36: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b37: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b38: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b39: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b40: [Double]¹ = alloc Double[Z :. e9 :. e10]
              b41: [Double]¹ = alloc Double[Z :. e9 :. e10]
              execute
                backpermute
                ( \(T2 x0 x1) -> T2 x0 x1
                , in (Z :. e4 :. e5) (((), T3 b23 b24 b25), b26)
                , out (Z :. e9 :. e10) (((), T3 b34 b35 b36), b37) )
              execute
                backpermute
                ( \(T2 x0 x1) -> T2 x0 x1
                , in (Z :. e7 :. e8) (((), T3 b27 b28 b29), b30)
                , out (Z :. e9 :. e10) (((), T3 b38 b39 b40), b41) )
              execute
                map
                ( \(T3 (T3 x0 x1 x2) x3 (T2 (T3 x4 x5 x6) x7)) ->
                    let
                      () = ()
                      T2 (T3 x8 x9 x10) x11 = T2 (T3 x4 x5 x6) x7
                      T3 x12 x13 x14 =
                        let
                          T3 x12 x13 x14 = T3 x8 x9 x10
                          T3 x15 x16 x17 = T3 x0 x1 x2
                        in
                        (let
                           T2 x18 x19 = T2 x15 x16 ; T2 x20 x21 = T2 x12 x13
                         in
                         T2 (x20 - x18) (x21 - x19), x14 - x17)
                      T3 x15 x16 x17 = T3 x12 x13 x14
                      x18 = x11
                          *
                          (let
                             x18 = 1.0
                                 /
                                 sqrt
                                   ((let
                                       T3 x18 x19 x20 = T3 x12 x13 x14
                                       T3 x21 x22 x23 = T3 x12 x13 x14
                                     in
                                     (let
                                        T2 x24 x25 = T2 x21 x22
                                        T2 x26 x27 = T2 x18 x19
                                      in
                                      x24 * x26 + x25 * x27)
                                     + x23 * x20)
                                    + 1.0e-9)
                           in
                           x18 * x18 * x18)
                    in
                    (let T2 x19 x20 = T2 x15 x16
                     in
                     T2 (x18 * x19) (x18 * x20), x18 * x17)
                , in
                (Z :. e9 :. e10)
                ((((), T3 b34 b35 b36), b37), (((), T3 b38 b39 b40), b41))
                , out (Z :. e9 :. e10) T3 b31 b32 b33 )
              b42: [Double]¹ = alloc Double[Z :. e9]
              b43: [Double]¹ = alloc Double[Z :. e9]
              b44: [Double]¹ = alloc Double[Z :. e9]
              b45: [Double]¹ = alloc Double[Z :. e9]
              b46: [Double]¹ = alloc Double[Z :. e9]
              b47: [Double]¹ = alloc Double[Z :. e9]
              execute
                fold-2
                ( \(T3 x0 x1 x2) (T3 x3 x4 x5) ->
                    let
                      T3 x6 x7 x8 = T3 x0 x1 x2 ; T3 x9 x10 x11 = T3 x3 x4 x5
                    in
                    (let
                       T2 x12 x13 = T2 x9 x10 ; T2 x14 x15 = T2 x6 x7
                     in
                     T2 (x14 + x12) (x15 + x13), x8 + x11)
                , in (Z :. e9 :. e10) T3 b31 b32 b33
                , out (Z :. e9) T3 b45 b46 b47 )
              execute
                map
                ( \(T3 x0 x1 x2) ->
                    let
                      T4 x3 x4 x5 (T3 x6 x7 x8) = T4 0.0 0.0 0.0 (T3 x0 x1 x2)
                      T3 x9 x10 x11 = T3 x3 x4 x5
                      T3 x12 x13 x14 = T3 x6 x7 x8
                    in
                    (let
                       T2 x15 x16 = T2 x12 x13 ; T2 x17 x18 = T2 x9 x10
                     in
                     T2 (x17 + x15) (x18 + x16), x11 + x14)
                , in (Z :. e9) T3 b45 b46 b47
                , out (Z :. e9) T3 b42 b43 b44 )
              e11: Int = compute min e2 e9
              b48: [Double]¹ = alloc Double[Z :. e11]
              b49: [Double]¹ = alloc Double[Z :. e11]
              b50: [Double]¹ = alloc Double[Z :. e11]
              b51: [Double]¹ = alloc Double[Z :. e11]
              b52: [Double]¹ = alloc Double[Z :. e11]
              b53: [Double]¹ = alloc Double[Z :. e11]
              b54: [Double]¹ = alloc Double[Z :. e11]
              b55: [Double]¹ = alloc Double[Z :. e11]
              b56: [Double]¹ = alloc Double[Z :. e11]
              b57: [Double]¹ = alloc Double[Z :. e11]
              execute
                backpermute
                ( \(T1 x0) -> T1 x0
                , in (Z :. e2) ((((), T3 b11 b12 b13), b14), T3 b15 b16 b17)
                , out (Z :. e11) ((((), T3 b48 b49 b50), b51), T3 b52 b53 b54) )
              execute
                backpermute
                ( \(T1 x0) -> T1 x0
                , in (Z :. e9) T3 b42 b43 b44
                , out (Z :. e11) T3 b55 b56 b57 )
              b58: [Int]¹ = alloc Int[Z]
              execute map (\x0 -> x0 + 1, in (Z) b18, out (Z) b58)
              return
                ( ( ()
                , (((), e11), ((((), T3 b48 b49 b50), b51), T3 b52 b53 b54)) )
                , T1 b58 )
          )
          (((), (((), e0), ((((), T3 b3 b4 b5), b6), T3 b7 b8 b9))), T1 b10)
      return (((), e2), ((((), T3 b11 b12 b13), b14), T3 b15 b16 b17))

Simplified OperationAcc:
\_: T1 [Double] ->
  \T1 (b0: [Int]) ->
    \T1 (b1: [Int]) ->
      T1 (e0: Int) =
        compute
          let T1 x0 = let () = () in T1 (let x0 = toIndex () () in (b0 !! x0))
          in
          T1 x0
      b2: [Double]¹ = alloc Double[Z :. e0]
      b3: [Double]¹ = alloc Double[Z :. e0]
      b4: [Double]¹ = alloc Double[Z :. e0]
      b5: [Double]¹ = alloc Double[Z :. e0]
      b6: [Double]¹ = alloc Double[Z :. e0]
      b7: [Double]¹ = alloc Double[Z :. e0]
      b8: [Double]¹ = alloc Double[Z :. e0]
      execute
        generate
        ( \(T1 x0) ->
            let () = ()
            in
            (let x1 = fromIntegral x0
             in
             T2 (T3 (sin x1) (cos x1) (tan x1)) (sin (x1 + 1.1)), let x1 = 0.0
                                                                  in
                                                                  T3 x1 x1 x1)
        , out (Z :. e0) ((((), T3 b2 b3 b4), b5), T3 b6 b7 b8) )
      e1: Int = compute 0
      b9: [Int] = unit e1
      T2 (T2 (e2: Int)
             (T3 (T3 (b10: [Double]) (b11: [Double]) (b12: [Double]))
                 (b13: [Double])
                 (T3 (b14: [Double]) (b15: [Double]) (b16: [Double]))))
         (_: T1 [Int]) =
        awhile ( ( ()
        , ( ((), Int)
        , ( (((), T3 [Double] [Double] [Double]), [Double])
        , T3 [Double] [Double] [Double] ) ) )
        , T1 [Int] )
          ( \( _: ( ()
                  , ( ((), Int)
                  , ( (((), T3 [Double] [Double] [Double]), [Double])
                  , T3 [Double] [Double] [Double] ) ) )
            , T1 (b10: [Int]) ) ->
              T1 (b11: [Word8]) =
                b11: [Word8]¹ = alloc Word8[Z]
                execute
                  map
                  ( \x0 ->
                      let () = ()
                      in
                      (x0 < (let x1 = toIndex () () in (b1 !! x1)), ())
                  , in (Z) b10
                  , out (Z) (b11, ()) )
                return (T1 b11)
              compute (b11 !! 0)
          )
          ( \T2 (T2 (e2: Int)
                    (T3 (T3 (b10: [Double]) (b11: [Double]) (b12: [Double]))
                        (b13: [Double])
                        (T3 (b14: [Double]) (b15: [Double]) (b16: [Double]))))
                (T1 (b17: [Int])) ->
              T2 (e3: Int) () =
                compute
                  let T2 x0 () = let () = () in T2 (let T1 x0 = T1 e2 in x0) ()
                  in
                  T2 x0 ()
              T2 (e4: Int) () =
                compute let T2 x0 _ = indexFull (T2 e3 ()) (T1 e2) in T2 x0 ()
              e5: Int = compute let T1 x0 = T1 e2 in x0
              T2 (e6: Int) () =
                compute let T2 x0 _ = indexFull (T2 () e5) (T1 e2) in T2 x0 ()
              e7: Int = compute min e4 e6
              e8: Int = compute min e2 e7
              b18: [Double]¹ = alloc Double[Z :. e8]
              b19: [Double]¹ = alloc Double[Z :. e8]
              b20: [Double]¹ = alloc Double[Z :. e8]
              b21: [Double]¹ = alloc Double[Z :. e8]
              b22: [Double]¹ = alloc Double[Z :. e8]
              b23: [Double]¹ = alloc Double[Z :. e8]
              b24: [Double]¹ = alloc Double[Z :. e8]
              execute
                backpermute
                ( \(T1 x0) -> T1 x0
                , in (Z :. e2) ((((), T3 b10 b11 b12), b13), T3 b14 b15 b16)
                , out (Z :. e8) ((((), T3 b18 b19 b20), b21), T3 b22 b23 b24) )
              b25: [Int]¹ = alloc Int[Z]
              execute map (\x0 -> x0 + 1, in (Z) b17, out (Z) b25)
              return
                ( ( ()
                , (((), e8), ((((), T3 b18 b19 b20), b21), T3 b22 b23 b24)) )
                , T1 b25 )
          )
          (((), (((), e0), ((((), T3 b2 b3 b4), b5), T3 b6 b7 b8))), T1 b9)
      return (((), e2), ((((), T3 b10 b11 b12), b13), T3 b14 b15 b16))

PartitionedAcc:
\_: T1 [Double] ->
  \T1 (b0: [Int]) ->
    \T1 (b1: [Int]) ->
      T1 (e0: Int) =
        compute
          let T1 x0 = let () = () in T1 (let x0 = toIndex () () in (b0 !! x0))
          in
          T1 x0
      e1: Int = compute 0
      b2: [Double]¹ = alloc Double[Z :. e0]
      b3: [Double]¹ = alloc Double[Z :. e0]
      b4: [Double]¹ = alloc Double[Z :. e0]
      b5: [Double]¹ = alloc Double[Z :. e0]
      b6: [Double]¹ = alloc Double[Z :. e0]
      b7: [Double]¹ = alloc Double[Z :. e0]
      b8: [Double]¹ = alloc Double[Z :. e0]
      b9: [Int] = unit e1
      execute
        generate
        ( \(T1 x0) ->
            let () = ()
            in
            (let x1 = fromIntegral x0
             in
             T2 (T3 (sin x1) (cos x1) (tan x1)) (sin (x1 + 1.1)), let x1 = 0.0
                                                                  in
                                                                  T3 x1 x1 x1)
        , out (Z :. e0) ((((), T3 b2 b3 b4), b5), T3 b6 b7 b8) )
      T2 (T2 (e2: Int)
             (T3 (T3 (b10: [Double]) (b11: [Double]) (b12: [Double]))
                 (b13: [Double])
                 (T3 (b14: [Double]) (b15: [Double]) (b16: [Double]))))
         (_: T1 [Int]) =
        awhile ( ( ()
        , ( ((), Int)
        , ( (((), T3 [Double] [Double] [Double]), [Double])
        , T3 [Double] [Double] [Double] ) ) )
        , T1 [Int] )
          ( \( _: ( ()
                  , ( ((), Int)
                  , ( (((), T3 [Double] [Double] [Double]), [Double])
                  , T3 [Double] [Double] [Double] ) ) )
            , T1 (b10: [Int]) ) ->
              b11: [Word8]¹ = alloc Word8[Z]
              execute
                map
                ( \x0 ->
                    let () = ()
                    in
                    (x0 < (let x1 = toIndex () () in (b1 !! x1)), ())
                , in (Z) b10
                , out (Z) (b11, ()) )
              T1 (b12: [Word8]) = return (T1 b11)
              compute (b12 !! 0)
          )
          ( \T2 (T2 (e2: Int)
                    (T3 (T3 (b10: [Double]) (b11: [Double]) (b12: [Double]))
                        (b13: [Double])
                        (T3 (b14: [Double]) (b15: [Double]) (b16: [Double]))))
                (T1 (b17: [Int])) ->
              T2 (e3: Int) () =
                compute
                  let T2 x0 () = let () = () in T2 (let T1 x0 = T1 e2 in x0) ()
                  in
                  T2 x0 ()
              e4: Int = compute let T1 x0 = T1 e2 in x0
              b18: [Int]¹ = alloc Int[Z]
              T2 (e5: Int) () =
                compute let T2 x0 _ = indexFull (T2 e3 ()) (T1 e2) in T2 x0 ()
              T2 (e6: Int) () =
                compute let T2 x0 _ = indexFull (T2 () e4) (T1 e2) in T2 x0 ()
              e7: Int = compute min e5 e6
              e8: Int = compute min e2 e7
              b19: [Double]¹ = alloc Double[Z :. e8]
              b20: [Double]¹ = alloc Double[Z :. e8]
              b21: [Double]¹ = alloc Double[Z :. e8]
              b22: [Double]¹ = alloc Double[Z :. e8]
              b23: [Double]¹ = alloc Double[Z :. e8]
              b24: [Double]¹ = alloc Double[Z :. e8]
              b25: [Double]¹ = alloc Double[Z :. e8]
              execute
                backpermute
                ( \(T1 x0) -> T1 x0
                , in (Z :. e2) ((((), T3 b10 b11 b12), b13), T3 b14 b15 b16)
                , out (Z :. e8) ((((), T3 b19 b20 b21), b22), T3 b23 b24 b25) )
              execute map (\x0 -> x0 + 1, in (Z) b17, out (Z) b18)
              return
                ( ( ()
                , (((), e8), ((((), T3 b19 b20 b21), b22), T3 b23 b24 b25)) )
                , T1 b18 )
          )
          (((), (((), e0), ((((), T3 b2 b3 b4), b5), T3 b6 b7 b8))), T1 b9)
      return (((), e2), ((((), T3 b10 b11 b12), b13), T3 b14 b15 b16))
SLV'd PartitionedAcc:
\_: T1 [Double] ->
  \T1 (b0: [Int]) ->
    \T1 (b1: [Int]) ->
      T1 (e0: Int) =
        compute
          let
            T1 x0 =
              let
                T1 x0 =
                  let () = () in T1 (let x0 = toIndex () () in (b0 !! x0))
              in
              T1 x0
          in
          T1 x0
      e1: Int = compute 0
      b2: [Double]¹ = alloc Double[Z :. e0]
      b3: [Double]¹ = alloc Double[Z :. e0]
      b4: [Double]¹ = alloc Double[Z :. e0]
      b5: [Double]¹ = alloc Double[Z :. e0]
      b6: [Double]¹ = alloc Double[Z :. e0]
      b7: [Double]¹ = alloc Double[Z :. e0]
      b8: [Double]¹ = alloc Double[Z :. e0]
      b9: [Int] = unit e1
      execute
        generate
        ( \(T1 x0) ->
            let () = ()
            in
            (let x1 = fromIntegral x0
             in
             T2 (T3 (sin x1) (cos x1) (tan x1)) (sin (x1 + 1.1)), let x1 = 0.0
                                                                  in
                                                                  T3 x1 x1 x1)
        , out (Z :. e0) ((((), T3 b2 b3 b4), b5), T3 b6 b7 b8) )
      T2 (T2 (e2: Int)
             (T3 (T3 (b10: [Double]) (b11: [Double]) (b12: [Double]))
                 (b13: [Double])
                 (T3 (b14: [Double]) (b15: [Double]) (b16: [Double]))))
         (_: T1 [Int]) =
        awhile ( ( ()
        , ( ((), Int)
        , ( (((), T3 [Double] [Double] [Double]), [Double])
        , T3 [Double] [Double] [Double] ) ) )
        , T1 [Int] )
          ( \( _: ( ()
                  , ( ((), Int)
                  , ( (((), T3 [Double] [Double] [Double]), [Double])
                  , T3 [Double] [Double] [Double] ) ) )
            , T1 (b10: [Int]) ) ->
              b11: [Word8]¹ = alloc Word8[Z]
              execute
                map
                ( \x0 ->
                    let () = ()
                    in
                    (x0 < (let x1 = toIndex () () in (b1 !! x1)), ())
                , in (Z) b10
                , out (Z) (b11, ()) )
              T1 (b12: [Word8]) = return (T1 b11)
              compute (b12 !! 0)
          )
          ( \T2 (T2 (e2: Int)
                    (T3 (T3 (b10: [Double]) (b11: [Double]) (b12: [Double]))
                        (b13: [Double])
                        (T3 (b14: [Double]) (b15: [Double]) (b16: [Double]))))
                (T1 (b17: [Int])) ->
              T2 (e3: Int) () =
                compute
                  let
                    T2 x0 () =
                      let
                        T2 x0 () =
                          let () = () in T2 (let T1 x0 = T1 e2 in x0) ()
                      in
                      T2 x0 ()
                  in
                  T2 x0 ()
              e4: Int = compute let T1 x0 = T1 e2 in x0
              b18: [Int]¹ = alloc Int[Z]
              T2 (e5: Int) () =
                compute
                  let
                    T2 x0 () =
                      let T2 x0 _ = indexFull (T2 e3 ()) (T1 e2) in T2 x0 ()
                  in
                  T2 x0 ()
              T2 (e6: Int) () =
                compute
                  let
                    T2 x0 () =
                      let T2 x0 _ = indexFull (T2 () e4) (T1 e2) in T2 x0 ()
                  in
                  T2 x0 ()
              e7: Int = compute min e5 e6
              e8: Int = compute min e2 e7
              b19: [Double]¹ = alloc Double[Z :. e8]
              b20: [Double]¹ = alloc Double[Z :. e8]
              b21: [Double]¹ = alloc Double[Z :. e8]
              b22: [Double]¹ = alloc Double[Z :. e8]
              b23: [Double]¹ = alloc Double[Z :. e8]
              b24: [Double]¹ = alloc Double[Z :. e8]
              b25: [Double]¹ = alloc Double[Z :. e8]
              execute
                backpermute
                ( \(T1 x0) -> T1 x0
                , in (Z :. e2) ((((), T3 b10 b11 b12), b13), T3 b14 b15 b16)
                , out (Z :. e8) ((((), T3 b19 b20 b21), b22), T3 b23 b24 b25) )
              execute map (\x0 -> x0 + 1, in (Z) b17, out (Z) b18)
              return
                ( ( ()
                , (((), e8), ((((), T3 b19 b20 b21), b22), T3 b23 b24 b25)) )
                , T1 b18 )
          )
          (((), (((), e0), ((((), T3 b2 b3 b4), b5), T3 b6 b7 b8))), T1 b9)
      return (((), e2), ((((), T3 b10 b11 b12), b13), T3 b14 b15 b16))

Schedule:
\_: ((), (Signal, *[Double])) ->
  \T1 (s0: Signal, r0: *[Int]) ->
    \T1 (s1: Signal, r1: *[Int]) ->
      \T2 (s2': Resolver, r2': *out Int)
          (T3 (T3 (s3': Resolver, r3': *out [Double])
                  (s4': Resolver, r4': *out [Double])
                  (s5': Resolver, r5': *out [Double]))
              (s6': Resolver, r6': *out [Double])
              (T3 (s7': Resolver, r7': *out [Double])
                  (s8': Resolver, r8': *out [Double])
                  (s9': Resolver, r9': *out [Double]))) ->
        await [s0]
        b0: [Int] = *r0
        T1 (e0: Int) =
        compute
          let
            T1 x0 =
              let
                T1 x0 =
                  let () = () in T1 (let x0 = toIndex () () in (b0 !! x0))
              in
              T1 x0
          in
          T1 x0
        e1: Int = compute 0
        b1 = alloc Double[Z :. e0]
        b2 = alloc Double[Z :. e0]
        b3 = alloc Double[Z :. e0]
        b4 = alloc Double[Z :. e0]
        b5 = alloc Double[Z :. e0]
        b6 = alloc Double[Z :. e0]
        b7 = alloc Double[Z :. e0]
        b8: [Int] = unit e1
        (s10, s10') = new signal
        (s11, s11') = new signal
        (s12, s12') = new signal
        (s13, s13') = new signal
        (s14, s14') = new signal
        (s15, s15') = new signal
        (s16, s16') = new signal
        7651097f40b2f3011d173f2d1c953a100ec90f4683b46c8b351cb829c1663662
        resolve [s10', s11', s12', s13', s14', s15', s16']
        (s17, s17') = new signal
        (r10, r10') = ref Int
        (s18, s18') = new signal
        (r11, r11') = ref [Double]
        (s19, s19') = new signal
        (r12, r12') = ref [Double]
        (s20, s20') = new signal
        (r13, r13') = ref [Double]
        (s21, s21') = new signal
        (r14, r14') = ref [Double]
        (s22, s22') = new signal
        (r15, r15') = ref [Double]
        (s23, s23') = new signal
        (r16, r16') = ref [Double]
        (s24, s24') = new signal
        (r17, r17') = ref [Double]
        fork {
          (s25, s25') = new signal
          resolve [s25']
          (r18, r18') = ref Int
          *r18' = e0
          (r19, r19') = ref [Double]
          *r19' = b1
          (r20, r20') = ref [Double]
          *r20' = b2
          (r21, r21') = ref [Double]
          *r21' = b3
          (r22, r22') = ref [Double]
          *r22' = b4
          (r23, r23') = ref [Double]
          *r23' = b5
          (r24, r24') = ref [Double]
          *r24' = b6
          (r25, r25') = ref [Double]
          *r25' = b7
          (r26, r26') = ref [Int]
          *r26' = b8
          awhile
            ( ()
            , ( ( ()
            , ( ((), (s25, r18))
            , ( (((), ((((), (s16, r19)), (s15, r20)), (s14, r21))), (s13, r22))
            , ((((), (s12, r23)), (s11, r24)), (s10, r25)) ) ) )
            , ((), (s25, r26)) ) )
            ( \T1 (T2 (T2 (s26: Signal, r27: *Int)
                          (T3 (T3 (s27: Signal, r28: *[Double])
                                  (s28: Signal, r29: *[Double])
                                  (s29: Signal, r30: *[Double]))
                              (s30: Signal, r31: *[Double])
                              (T3 (s31: Signal, r32: *[Double])
                                  (s32: Signal, r33: *[Double])
                                  (s33: Signal, r34: *[Double]))))
                      (T1 (s34: Signal, r35: *[Int]))) ->
                \(s35': Resolver, r36': *out Word8) ->
                  \T1 (T2 (T2 (s36': Resolver, r37': *out Int)
                              (T3 (T3 (s37': Resolver, r38': *out [Double])
                                      (s38': Resolver, r39': *out [Double])
                                      (s39': Resolver, r40': *out [Double]))
                                  (s40': Resolver, r41': *out [Double])
                                  (T3 (s41': Resolver, r42': *out [Double])
                                      (s42': Resolver, r43': *out [Double])
                                      (s43': Resolver, r44': *out [Double]))))
                          (T1 (s44': Resolver, r45': *out [Int]))) ->
                    (s45, s45') = new signal
                    (r46, r46') = ref Word8
                    fork {
                      await [s34, s1]
                      b9 = alloc Word8[Z]
                      b10: [Int] = *r1
                      b11: [Int] = *r35
                      a76cd2344793ec0b4e16b54772b4ab271afc1b9228e7da5e0e5cfe498fe18cee
                      (s46, s46') = new signal
                      (r47, r47') = ref [Word8]
                      *r47' = b9
                      resolve [s46']
                      await [s46]
                      b12: [Word8] = *r47
                      e2: Word8 = compute (b12 !! 0)
                      *r46' = e2
                      resolve [s45']
                    }
                    await [s45]
                    e2: Word8 = *r46
                    if e2 then
                      e3: Word8 = compute 1
                      *r36' = e3
                      resolve [s35']
                      await [s26]
                      e4: Int = *r27
                      T2 (e5: Int) () =
                      compute
                        let
                          T2 x0 () =
                            let
                              T2 x0 () =
                                let () = () in T2 (let T1 x0 = T1 e4 in x0) ()
                            in
                            T2 x0 ()
                        in
                        T2 x0 ()
                      e6: Int = *r27
                      e7: Int = compute let T1 x0 = T1 e6 in x0
                      b9 = alloc Int[Z]
  